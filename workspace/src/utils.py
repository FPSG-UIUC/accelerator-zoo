from fibertree_bootstrap import *

from teaal.parse import *
from teaal.trans.hifiber import HiFiber

def compile(yaml, generate_video = True):
    str_yaml = yaml
    if(generate_video == False):
       index = str_yaml.find("spacetime")
       str_yaml = str_yaml[:index]

    einsum = Einsum.from_str(str_yaml)
    mapping = Mapping.from_str(str_yaml)
    arch = Architecture.from_str(str_yaml)
    bindings = Bindings.from_str(str_yaml)
    format_ = Format.from_str(str_yaml)

    hifiber = HiFiber(einsum, mapping, arch, bindings, format_)

    get_ipython().set_next_input("# Autogenerated HiFiber\n\n" + str(hifiber))

def check_matmul(A, B, Z):
    # Note: A, B, and Z should be un-partitioned
    A_MK = A.swizzleRanks(rank_ids=["M", "K"])
    B_NK = B.swizzleRanks(rank_ids=["N", "K"])
    Z_MN = Z.swizzleRanks(rank_ids=["M", "N"])

    Z_MN_corr = Tensor(rank_ids=["M", "N"], name="Z")
    z_m = Z_MN_corr.getRoot()
    a_m = A_MK.getRoot()
    b_n = B_NK.getRoot()
    for m, (z_n, a_k) in z_m << a_m:
        for n, (z_ref, b_k) in z_n << b_n:
            for k, (a_val, b_val) in a_k & b_k:
                z_ref += a_val * b_val

    print("Result correct?", Z_MN == Z_MN_corr)

def check_conv(I, F, O, stride=1):
    # Note: I, F, and O should be un-partitioned

    I_NCHW = I.swizzleRanks(rank_ids=["N", "C", "H", "W"])
    F_MCRS = F.swizzleRanks(rank_ids=["M", "C", "R", "S"])
    O_NMEF = O.swizzleRanks(rank_ids=["N", "M", "E", "F"])
    N, C, H, W = I_NCHW.getShape()
    M, C, R, S = F_MCRS.getShape()
    N, M, E, F = O_NMEF.getShape()

    O_NMEF_corr = Tensor(rank_ids=["N", "M", "E", "F"], name="O", shape=[N, M, E, F])
    o_n = O_NMEF_corr.getRoot()
    i_n = I_NCHW.getRoot()
    f_m = F_MCRS.getRoot()
    for n, (o_m, i_c) in o_n << i_n:
        for m, (o_e, f_c) in o_m << f_m:
            for e, o_f in o_e.iterRangeShapeRef(0, E, 1):
                for f, o_ref in o_f.iterRangeShapeRef(0, F, 1):
                    for c, (i_h, f_r) in i_c & f_c:
                        for r, (i_w, f_s) in i_h.project(trans_fn=lambda h: h + -stride * e, interval=(0, R)) & f_r:
                            for s, (i_val, f_val) in i_w.project(trans_fn=lambda w: w + -stride * f, interval=(0, S)) & f_s:
                                o_ref += i_val * f_val

    print("Result correct?", O_NMEF == O_NMEF_corr)

