from fibertree_bootstrap import *

from teaal.parse import *
from teaal.trans.hifiber import HiFiber

def compile(yaml, generate_video = True):
    str_yaml = yaml
    if(generate_video == False):
       index = str_yaml.find("spacetime")
       str_yaml = str_yaml[:index]

    einsum = Einsum.from_str(str_yaml)
    mapping = Mapping.from_str(str_yaml)
    arch = Architecture.from_str(str_yaml)
    bindings = Bindings.from_str(str_yaml)
    format_ = Format.from_str(str_yaml)

    hifiber = HiFiber(einsum, mapping, arch, bindings, format_)

    get_ipython().set_next_input("# Autogenerated HiFiber\n\n" + str(hifiber))

def check_matmul(A, B, Z):
    # Note: A, B, and Z should be un-partitioned
    A_MK = A.swizzleRanks(rank_ids=["M", "K"])
    B_NK = B.swizzleRanks(rank_ids=["N", "K"])
    Z_MN = Z.swizzleRanks(rank_ids=["M", "N"])

    Z_MN_corr = Tensor(rank_ids=["M", "N"], name="Z")
    z_m = Z_MN_corr.getRoot()
    a_m = A_MK.getRoot()
    b_n = B_NK.getRoot()
    for m, (z_n, a_k) in z_m << a_m:
        for n, (z_ref, b_k) in z_n << b_n:
            for k, (a_val, b_val) in a_k & b_k:
                z_ref += a_val * b_val

    print("Result correct?", Z_MN == Z_MN_corr)

def check_conv(I, F, O, stride=1):
    # Note: I, F, and O should be un-partitioned

    I_NCHW = I.swizzleRanks(rank_ids=["N", "C", "H", "W"])
    F_MCRS = F.swizzleRanks(rank_ids=["M", "C", "R", "S"])
    O_NMEF = O.swizzleRanks(rank_ids=["N", "M", "E", "F"])
    N, C, H, W = I_NCHW.getShape()
    M, C, R, S = F_MCRS.getShape()
    N, M, E, F = O_NMEF.getShape()

    O_NMEF_corr = Tensor(rank_ids=["N", "M", "E", "F"], name="O", shape=[N, M, E, F])
    o_n = O_NMEF_corr.getRoot()
    i_n = I_NCHW.getRoot()
    f_m = F_MCRS.getRoot()
    for n, (o_m, i_c) in o_n << i_n:
        for m, (o_e, f_c) in o_m << f_m:
            for e, o_f in o_e.iterRangeShapeRef(0, E, 1):
                for f, o_ref in o_f.iterRangeShapeRef(0, F, 1):
                    for c, (i_h, f_r) in i_c & f_c:
                        for r, (i_w, f_s) in i_h.project(trans_fn=lambda h: h + -stride * e, interval=(0, R)) & f_r:
                            for s, (i_val, f_val) in i_w.project(trans_fn=lambda w: w + -stride * f, interval=(0, S)) & f_s:
                                o_ref += i_val * f_val

    print("Result correct?", O_NMEF == O_NMEF_corr)

def check_MTTKRP(A_IJK, B_JF, C_KF, Y):
    T_IJF = Tensor(rank_ids=["I", "J", "F"], name="T")
    t_i = T_IJF.getRoot()
    a_i = A_IJK.getRoot()
    c_k = C_KF.getRoot()
    for i_pos, (i, (t_j, a_j)) in enumerate(t_i << a_i):
        for j_pos, (j, (t_f, a_k)) in enumerate(t_j << a_j):
            for k_pos, (k, (a_val, c_f)) in enumerate(a_k & c_k):
                for f_pos, (f, (t_ref, c_val)) in enumerate(t_f << c_f):
                    t_ref += a_val * c_val
    
    Y_IF = Tensor(rank_ids=["I", "F"], name="Y")
    y_i = Y_IF.getRoot()
    t_i = T_IJF.getRoot()
    b_j = B_JF.getRoot()
    for i_pos, (i, (y_f, t_j)) in enumerate(y_i << t_i):
        for j_pos, (j, (t_f, b_f)) in enumerate(t_j & b_j):
            for f_pos, (f, (y_ref, (t_val, b_val))) in enumerate(y_f << (t_f & b_f)):
                y_ref += t_val * b_val
    print("Result correct?", Y == Y_IF)

def check_TTMc(A_IJK, B_JV, C_KU, Y):
    T_IJU = Tensor(rank_ids=["I", "J", "U"], name="T")
    t_i = T_IJU.getRoot()
    a_i = A_IJK.getRoot()
    c_k = C_KU.getRoot()
    for i_pos, (i, (t_j, a_j)) in enumerate(t_i << a_i):
        for j_pos, (j, (t_u, a_k)) in enumerate(t_j << a_j):
            for k_pos, (k, (a_val, c_u)) in enumerate(a_k & c_k):
                for u_pos, (u, (t_ref, c_val)) in enumerate(t_u << c_u):
                    t_ref += a_val * c_val
    Y_IVU = Tensor(rank_ids=["I", "V", "U"], name="Y")
    y_i = Y_IVU.getRoot()
    t_i = T_IJU.getRoot()
    b_j = B_JV.getRoot()
    for i_pos, (i, (y_v, t_j)) in enumerate(y_i << t_i):
        for j_pos, (j, (t_u, b_v)) in enumerate(t_j & b_j):
            for v_pos, (v, (y_u, b_val)) in enumerate(y_v << b_v):
                for u_pos, (u, (y_ref, t_val)) in enumerate(y_u << t_u):
                    y_ref += t_val * b_val
    print("Result correct?", Y == Y_IVU)

def check_matrix_matrix_mul(A_IJ, B_JK, Y):
    Y_IK = Tensor(rank_ids=["I", "K"], name="Y")
    y_i = Y_IK.getRoot()
    a_i = A_IJ.getRoot()
    b_j = B_JK.getRoot()
    for i_pos, (i, (y_k, a_j)) in enumerate(y_i << a_i):
        for j_pos, (j, (a_val, b_k)) in enumerate(a_j & b_j):
            for k_pos, (k, (y_ref, b_val)) in enumerate(y_k << b_k):
                y_ref += a_val * b_val
    print("Result correct?", Y == Y_IK)

def check_matrix_vector_mul(A_IJ, B_J, Y):
    Y_I = Tensor(rank_ids=["I"], name="Y")
    y_i = Y_I.getRoot()
    a_i = A_IJ.getRoot()
    b_j = B_J.getRoot()
    for i_pos, (i, (y_ref, a_j)) in enumerate(y_i << a_i):
        for j_pos, (j, (a_val, b_val)) in enumerate(a_j & b_j):
            y_ref += a_val * b_val
    print("Result correct?", Y == Y_I)
